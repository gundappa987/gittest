SQL STATEMENTS
------------------

1)DQL/DRL(data query /retrieval language):- SELECT  [It will not change any data inside the database/table]

2)DDL(data definition lang):- CREATE, ALTER , DROP, TRUNCATE , RENAME.

3)DML(data manipulation lang):- INSERT ,UPDATE , DELETE , MERGE, EXPLAIN PLAN.

4)DCL(data control lang):- GRANT, REVOKE.

5)TCL(transaction control lang):- COMMIT,ROLLBACK,SAVE POINT.


6)SCL(session control):- ALTER SESSION.	} Mostly used by DBAs
7)SCL(system controlm):- ALTER SYSTEM.	} Mostly used by DBAs

==================================

DDL:-
-----
* Help us to create or modify the structure of the table

____________________________________________________________

CREATE

____________________________________________________________

- Create helps to create new tables.

Eg:-
====

Create the following tables:
============================

prod
====
pid   		(PK)
pname 		(NN)


orders
======
ord_id 		(PK)
prod_id		(FK)
ord_dt
qty   		( >0 )
price 		(default 0)

======================================

create table prod
(
  pid		number(5)	primary key,
  pname		varchar(9)	not null
)
/

create table orders
(
  ord_id	number(5)	primary key,		
  prod_id	number(5)	references prod(pid),	
  ord_dt	date,
  qty		number(3)	check (qty>0),
  price		number(9,2)	default 0
)
/

================================================================
Types of Constraints:

NOT NULL : Will not allow NULL(empty) Values
UNIQUE	 : Will not allow duplicate Values
PK	 : NN + UNIQUE, should be only one per table.
FK	 : Creates a relationship between any 2 tables.	
CHECK	 : Provides conditions based on business requirements.
DEFAULT  : Provides default value.


Methods of giving the constraints:-
-----------------------------------

a) Column level : constraints given along with columns(cannot take composite keys)

b) Table  level : constraints given after all the columns(can take composite keys)

c) After table creation : using ALTER statement


** A constraint will have a name
** In column-level oracle will give a default name for it.
Eg:-
SYS_C001
SYS_C002



** In table-level we will give a name for a constraint.
** DEFAULT & NOT NULL should be at column level.
** Composite keys should be always at table level.




--Table Level Constraints
create table orders11
(
  ord_id	number(5),
  prod_id	number(5),
  ord_dt	date 		not null,
  qty		number(3),
  price		number(9,2)  default 0 ,
 CONSTRAINT  ord_pk  PRIMARY KEY(ord_id, prod_id),
 CONSTRAINT  ord_fk  FOREIGN KEY(prod_id) REFERENCES prod(pid),
 CONSTRAINT  ord_ch1 CHECK(qty>0)
)
/


Assignment: Differences b/w Column & Table level [2-4 differences]
 column level constraint                                          Table level constraint
1) it along with column level                             1) it is given by all column
2) it has take default name of constriant                 2) here you can take name of constriant 
3) here can not take a composite primary key              3) here you can take composite primary key
4) default and not null constraint along with             4)
  column level                                 

==============================================================================

CTAS (CREATE TABLE AS SELECT) - helps to backup/copy a table from another table.

==============================================================================

create table dept_bkup
as
select * 
from dept 
where deptno=20;


select * 
from dept_bkup;


**When we run CTAS, only NOT NULL constraint is copied but rest of the constraints are not copied..



--creating a table without data (only structure is created)

create table emp_bkup1
as
select * 
from emp
where 1=2;  -- universal false condition

Eg:-
----
..
where 'a' = 'b' ; -- universal false condition
------------------------------------
..
where 20=40 ; -- universal false condition
------------------------------------
..
where empno = -1;
------------------------------------



____________________________________________________________

RENAME
____________________________________________________________
- IT HELPS TO RENAME a TABLE.

Eg:-
====

SQL> rename t2 to t9;

==============================================================================================


____________________________________________________________

DROP & TRUNCATE
____________________________________________________________
* Drop will remove both structure and the data.
  Truncate removes  only data & structure is kept as it is. 


* Drop can be flashed-back (can be recovered) ..
  Truncate cannot be flashed back.

* Truncate is faster, [TRUNCATE never writes the data to recyclebin]
  where as DROP is slower compared to truncate.

* Truncate will release the space
  whereas DROP will not release the space


Eg:-
====

CREATE TABLE T4 AS SELECT * FROM DEPT;

CREATE TABLE T2 AS SELECT * FROM DEPT;

DROP TABLE T4;

TRUNCATE TABLE T2;

DESC T4;          -- ERROR - object T4 does not exist

DESC T2;   	  -- it works
        
SELECT * FROM T2; -- works but no rows would be selected

==============================================================================================

Flashback Concepts:-
====================
From 10g onwards we can flashback a table which is being dropped.

RecycleBin: (SYSTEM TABLE THAT STORES DROPPED OBJECTS INFORMATION)


Table ----DROP------> RecycleBin --------FLASHBACK----> Restore it
			 |
			 |
			 |PURGE
			 |
			 |
			Remove Permanently


sql> flashback table t4 to before drop;

sql> drop table t1;

sql> purge table t1; -- removes from recyclebin

sql> drop table t2 purge; -- permanent removal 

sql> show recyclebin;

sql> purge recyclebin;

sql> flashback table dept2 to before drop rename to dept4;   -->> ?? find out what is this command.

** recylebin objects would be prefixed with 'BIN$'

-- selecting from RECYCLEBIN table
sql> select original_name, object_name from recyclebin order by 1;




____________________________________________________________

ALTER:- 
____________________________________________________________
- ALTER is used for changing the column properties of a table.
- It is also used to change data type and data size and rename the constraints.

a) Adding a column
------------------
SQL> alter table prod add prod_comments varchar(20);

sql> alter table t9 add (col1 number(6), col2 number);

b) Dropping a column
--------------------
SQL> alter table prod drop column prod_comments;

c) Rename a column
==================
SQL> alter table prod rename column pid to prod_id;

d) MODIFY (Should be used along with ALTER)
===========================================
	- Changes the Datatype
	- Changes the size
	- Adds/removes the DEFAULT/NOT NULL constraint only

SQL> ALTER TABLE prod MODIFY pid NUMBER(6);

SQL> ALTER TABLE cust MODIFY phone VARCHAR(10); -->from NUMBER to VARCHAR
      --> TO change the datatype, the column should be empty.

sql> alter table orders modify price default 100;

sql> alter table orders modify price default null;

sql> alter table orders modify price not null;

sql> alter table orders modify price null;

note:- **************************************************
======
-- table must be empty to add mandatory (NOT NULL) column, 
   otherwise we should give default value along with NOT NULL.

sql> alter table dept add head_quarters varchar(20) default 'x' not null;
===============================================================================

e) Add/remove a constraint
==========================
SQL> ALTER TABLE prod ADD CONSTRAINT prd_pk primary key(pid);

SQL> ALTER TABLE orders DROP CONSTRAINT ord_fk;


f) Disabling/Enabling a constraint
==================================
Status of the constraint:-
a) enable 	: active (default)
b) disable	: in-active

SQL> ALTER TABLE ORDERS DISABLE CONSTRAINT ORD_CHk;
SQL> ALTER TABLE ORDERS ENABLE  CONSTRAINT ORD_CHk;

===============================================



DMLS:-
======

____________________________________________________________

INSERT
___________________________________________________________

- It adds a new record to a table

insert into prod  values(1001,'Desktop');

insert into prod (pid)  values(1008);  --insertion to only specific columns

insert into prod  values(&pid, '&pnm') ; 

SQL> set verify off;   -- It turns-off the verification ..


NOTE:	& is used to substitue the values.
=====

insert into orders values(7722, 1001, '01-jan-2014' , 2, 8790.2);

Assignment: insert data which will fail all the constraints one-by-one
-----------

insert into orders(ORD_ID, PROD_ID, ORD_DT) values(7791, 1001, '09-jan-2014');


-- COPYING DATA FROM TABLE1 TO TABLE2  [TABLE SHOULD BE EXISTING]

sql> insert into emp1 select * from emp ;


____________________________________________________________

UPDATE
____________________________________________________________

- It will update one or more records/columns

update orders 
	set qty = 5 , 
	    ord_dt = sysdate 
	where ord_id = 7722;


update prod 
 set pname=null --> truncating a column.
/


update prod 
 set pname='' --> truncating a column.
/

update emp1
	set sal = (SELECT MAX(SAL) FROM EMP)
	where job = 'MANAGER';

___________________________________________________________

DELETE
___________________________________________________________

delete from emp1 where deptno=20
/

delete from emp1
/




TCL:-
-----

- Controls the behaviour of DML statements

___________________________________________________________

ROLLBACK
___________________________________________________________
 * It roll back (undo) the DML changes.


___________________________________________________________
COMMIT
_________________________________________________________
* It  saves the changes permanently. 


NOTE:-
------
* After  commit  we cannot rollback and viceversa.

* DDL Statements are auto-commited and hence can never be rolled back.

* whenever dml statements are  executed, the changes stored are in "undo segments".
 whenever dml statements are executed , the changes stored are in ''undo segments''

* after rollback or commit, the data is removed from undo segments.

* DDL STATEMENTS are faster  compared to DML as UNDO data is not generated for DDLs.


___________________________________________________________
SAVE POINT:-
___________________________________________________________

* save point is like a pointer till where  DMLs can be rolled back (Selective rollback)

* we cannot commit to a save point we can only rollback to a save point.
-----------------


Eg:-
====
SQL> COMMIT;

SQL> ROLLBACK;

SQL> ROLL;

=======================

SQL> delete from emp ;

sql> select * from emp; 	-- no rows

sql> rollback;

sql> select * from emp;		-- rows

=========================== 


ROLLBACK SCENARIOS:

a)
delete from x;
update y set sal=2000;
insert into z values(1000);
rollback;
===========================
**All the statements will be rolled back

b) 
==========================
delete from x;
update y set sal=2000;
commit;
insert into z values(1000);
rollback;
===========================
**Only INSERT is rolled back & rest are committed.

c) 
==========================
delete from x ;
update y set sal=2000 ;
alter table prod add comm number; --> it is DDL stmt.; it will commit itself
				 and COMMITs the above DML statements implicitly.
insert into z values(1000);
rollback;
===========================
**Only INSERT is rolled back & rest are committed.

d)
=================
delete from x;
commit;
rollback; --> STATEMENT WORKS FINE, its of no use
=================
**Nothing is rolled back as COMMIT has occcured first


e) Session exit scenarios on rollback.
[during abnormal exit AUTO ROLLBACK will occur & 
 during normal exit they will be  committed automatically ]



============================Save Point Scenarios======================
a)
insert ...
update ...
savepoint x;
delete ...
rollback to x;
commit;
==================================
** Here only Delete is rolled back, INSERT & UPDATE will be committed.

b)
===========================
insert ...
update ...
savepoint x;
delete ...
rollback; -->> complete rollback, SP is removed.
==========================
** All are rolled back

c)
===========================
insert ....
update ....
savepoint x;
delete ....
commit; --> All are committed and SP is killed.
rollback to x; --error.
==========================
** Commits all the DMLs and throws an error "Savepoint x not exists"

d)
===============================
insert .....
savepoint y;
delete .....
savepoint x;
update .....
rollback to x;
rollback to y; 
====================================================================
** we can have multiple savepoints. If we rollback the outer savepoint, then all
the inner DMLs will also be rolled back..
====================================================================


Transaction:-
=============

A transaction is a set of DML statements which will be committed or rolled back 
at once..

A transaction is ended with a COMMIT or a ROLLBACK.


sql> insert ...     --> txn1 starts.		}
sql> update ...	    --> txn1 continues.		}
sql> delete ...     --> txn1 continues.		}

sql> rollback; 	    --> txn1 ends.
=========================================

sql> insert ...     --> txn2 starts.		}
sql> update ...	    --> txn2 continues.		}

sql> alter  ...	    --> txn2 ends
=========================================

For every COMMIT Oracle will generate a SCN  - System Change Number ..


To know the current SCN :
=========================

SELECT dbms_flashback.get_system_change_number
FROM DUAL;


SELECT current_scn
FROM V$DATABASE;


========================================================                                                                                                       
-- Differences between PK & FK

        PK                                            FK
------------                                         --------------
1) It doesnot allow null values.               1) it allows null values

 
2) only one pk per table                       2) fk can be more than one.

3) PK is mandatory in master table.            3) fk is mandatory in child table.

4)pk identiefies unique record                 4)it helps to create relationship b/n two tables.

5)pk creates an index automatically            5)fk doesnot create an index.


========================================================                                                                                                       
-- Differences between DML & DDL

      DML                                         DDL
----------                                  ------------
*data manipulation lang                   * data defn lang

* dml can be rolled back                  * ddl cannot be rolled back                
* dml operations are first                * ddl operations are executed on  
saved in undio segmet                      table.

*dml are not auto committed                * ddl are auto committed.

*dml are  slower                          * ddl are faster compared to dml.


================================================================================================================                                               
-- diff b/n rollback and commit

  ROLL BACK                                COMMIT.
 ---------                                --------

* It restores database to original       *it saves changes permanently.
 since last commit.                                                                  

================================================================================================================                                               
      ROLLBACK                             SAVEPOINT
   -----------                            ----------------
*This is for undoing the wokdone in     *save point is pointer till where  
 current transaction                      dmls can be rolled back(selective rollback)

================================================================================================================                                               
-- diff b/n truncate    and  drop

      TRUNCATE                            DROP
 ---------------                       ------------------ 

* truncate removes only data           * drop will remove both structure and 
   but structure is kept as it is         data

* truncate cannot be flahed back       * drop can be flashed back from 10g onwards

* truncate is faster                    * drop is slower compared to truncate
 
================================================================================================================                                               
-- diff b/n truncate and delete

    TRUNCATE                          DELETE
 --------------                    -------------------

* truncate is a ddl statement         * delete is a dml statement

* truncte cannot be rolled back       * delete can be rolled back.

* we cannot use "where" clause within * we can use "where" where caluse with delete
 truncate                              to filter or delete specific records.

* truncate will release space 	     * Delete will not release the space.

* truncate is faster                 * delete is slower

==========================================================================================================



===========
ASSIGNMENTS
===========

Difference b/w 
	a)DML & DDL
              DML                                                          DDL
  1) DATA MANUPULATION  LANGUAGE                                 1) DATA DEFINATION LANGUAGE 
  2) IT CAN NOT AUTO COIMMITED                                   2) IT IS AUTO COMMMITED 
  3) IT SLOWER THAN DML                                          3) IT IS FASTER THAN DDL
  4) ANY DML CHANGES DML IS STORE THE DATA IN                    4) ANY CHANGES IN DDL CAN NOT WRITE DATA IN UNDO SEGMENT 
   UNDO SEGMENT                               
  5) IT HAS ROLLBACKED                                           5) IT HAS CAN NOT ROLLBACKED 


	1)ROLLBACK                                                              2) COMMIT
     1) IT IS RESTORES THE DATABASE TO ORGINAL SINCE LAST COMMIT               1)  IT IS SAVE CHANGES PERMANETLY
	C)ROLLBACK, SAVEPOINT
    
	D)TRUNCATE, DROP   **** (2 DIFFERENCES)
	E)TRUNCATE, DELETE **** (4 DIFFERENCES)
	F) DROP, DELETE
	G) CHAR, VARCHAR, VARCHAR2
	H) PK & FK
	I) flashback & rollback


What is DELETE CASCADE ?

How do we use CASCADE in DROP statement?

Differences between Column level & table level constraints?

What is SCN (System Change Number) ? When it is generated ?

What is a transaction ?



 

















